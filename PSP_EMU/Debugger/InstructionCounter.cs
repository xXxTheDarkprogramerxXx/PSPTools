using System;
using System.Collections.Generic;

/* This file is part of pspsharp.
 pspsharp is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 pspsharp is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with pspsharp.  If not, see <http://www.gnu.org/licenses/>.
 */
namespace pspsharp.Debugger
{

	using Instruction = pspsharp.Allegrex.Common.Instruction;
	using SceModule = pspsharp.HLE.kernel.types.SceModule;
	using Utilities = pspsharp.util.Utilities;

	using SwingWorker = com.jidesoft.utils.SwingWorker;

	/// 
	/// <summary>
	/// @author George
	/// </summary>
	public class InstructionCounter : javax.swing.JFrame, PropertyChangeListener
	{

		private const long serialVersionUID = 1L;
		private Task task;
		private SceModule module;

		/// <summary>
		/// Creates new form InstructionCounter
		/// </summary>
		public InstructionCounter()
		{
			initComponents();

			WindowPropSaver.loadWindowProperties(this);
		}

		public virtual SceModule Module
		{
			set
			{
				this.module = value;
				RefreshWindow();
			}
		}

		public virtual void RefreshWindow()
		{
			if (module == null)
			{
				return;
			}

			resetCounting();
			areastatus.Text = "";

			if (module.text_addr == 0)
			{
				textcheck.Enabled = false;
				textcheck.Selected = false;
			}
			else
			{
				textcheck.Enabled = true;
				textcheck.Selected = true;
				areastatus.append("Found .text section at " + module.text_addr.ToString("x") + " size " + module.text_size + "\n");
			}

			if (module.initsection[0] == 0)
			{
				initcheck.Enabled = false;
				initcheck.Selected = false;
			}
			else
			{
				initcheck.Enabled = true;
				initcheck.Selected = true;
				areastatus.append("Found .init section at " + module.initsection[0].ToString("x") + " size " + module.initsection[1] + "\n");
			}

			if (module.finisection[0] == 0)
			{
				finicheck.Enabled = false;
				finicheck.Selected = false;
			}
			else
			{
				finicheck.Enabled = true;
				finicheck.Selected = true;
				areastatus.append("Found .fini section at " + module.finisection[0].ToString("x") + " size " + module.finisection[1] + "\n");
			}

			if (module.stubtextsection[0] == 0)
			{
				stubtextcheck.Enabled = false;
				stubtextcheck.Selected = false;
			}
			else
			{
				stubtextcheck.Enabled = true;
				stubtextcheck.Selected = true;
				areastatus.append("Found .sceStub.text at " + module.stubtextsection[0].ToString("x") + " size " + module.stubtextsection[1]);
			}

			pack();
		}

		/// <summary>
		/// This method is called from within the constructor to initialize the form.
		/// WARNING: Do NOT modify this code. The content of this method is always
		/// regenerated by the Form Editor.
		/// </summary>
//JAVA TO C# CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
//ORIGINAL LINE: @SuppressWarnings("unchecked") private void initComponents()
		private void initComponents()
		{

			textcheck = new javax.swing.JCheckBox();
			initcheck = new javax.swing.JCheckBox();
			finicheck = new javax.swing.JCheckBox();
			lblCountWhat = new javax.swing.JLabel();
			progressBar = new javax.swing.JProgressBar();
			btnStart = new javax.swing.JButton();
			jScrollPane1 = new javax.swing.JScrollPane();
			areastatus = new javax.swing.JTextArea();
			jScrollPane2 = new javax.swing.JScrollPane();
			OpcodeTable = new javax.swing.JTable();
			stubtextcheck = new javax.swing.JCheckBox();
			btnSave = new javax.swing.JButton();

			java.util.ResourceBundle bundle = java.util.ResourceBundle.getBundle("pspsharp/languages/pspsharp"); // NOI18N
			Title = bundle.getString("InstructionCounter.title"); // NOI18N
			Resizable = false;

			textcheck.Text = ".text"; // NOI18N

			initcheck.Text = ".init"; // NOI18N

			finicheck.Text = ".fini"; // NOI18N

			lblCountWhat.Text = bundle.getString("InstructionCounter.lblCountWhat.text"); // NOI18N

			btnStart.Text = bundle.getString("InstructionCounter.btnStart.text"); // NOI18N
			btnStart.addActionListener(new ActionListenerAnonymousInnerClass(this));

			areastatus.Columns = 20;
			areastatus.Font = new java.awt.Font("Courier New", 0, 12); // NOI18N
			areastatus.Rows = 4;
			jScrollPane1.ViewportView = areastatus;

			OpcodeTable.AutoCreateRowSorter = true;
			OpcodeTable.Model = new DefaultTableModelAnonymousInnerClass(this, new object [][] { }, new string [] { "Opcode", "Category", "Count" });
			OpcodeTable.SelectionMode = javax.swing.ListSelectionModel.SINGLE_SELECTION;
			jScrollPane2.ViewportView = OpcodeTable;

			stubtextcheck.Text = ".sceStub.text"; // NOI18N

			btnSave.Text = bundle.getString("InstructionCounter.btnSave.text"); // NOI18N
			btnSave.addActionListener(new ActionListenerAnonymousInnerClass2(this));

			javax.swing.GroupLayout layout = new javax.swing.GroupLayout(ContentPane);
			ContentPane.Layout = layout;
			layout.HorizontalGroup = layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addContainerGap().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addComponent(btnStart).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addComponent(progressBar, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, short.MaxValue)).addComponent(jScrollPane1).addComponent(jScrollPane2, javax.swing.GroupLayout.Alignment.TRAILING).addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup().addGap(0, 0, short.MaxValue).addComponent(btnSave)).addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup().addComponent(lblCountWhat, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, short.MaxValue).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addGroup(layout.createSequentialGroup().addComponent(textcheck).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(initcheck).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addComponent(finicheck)).addComponent(stubtextcheck, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, short.MaxValue)))).addContainerGap());
			layout.VerticalGroup = layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addContainerGap().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(finicheck).addComponent(initcheck).addComponent(textcheck).addComponent(lblCountWhat)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(stubtextcheck).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addComponent(progressBar, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, short.MaxValue).addComponent(btnStart, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, short.MaxValue)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 59, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 402, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(btnSave).addContainerGap());

			pack();
		} // </editor-fold>//GEN-END:initComponents

		private class ActionListenerAnonymousInnerClass : java.awt.@event.ActionListener
		{
			private readonly InstructionCounter outerInstance;

			public ActionListenerAnonymousInnerClass(InstructionCounter outerInstance)
			{
				this.outerInstance = outerInstance;
			}

			public void actionPerformed(java.awt.@event.ActionEvent evt)
			{
				outerInstance.btnStartActionPerformed(evt);
			}
		}

		private class DefaultTableModelAnonymousInnerClass : DefaultTableModel
		{
			private readonly InstructionCounter outerInstance;

			public DefaultTableModelAnonymousInnerClass(InstructionCounter outerInstance, object[][] new, string[] new) : base(new object [][] { }, new string [] { "Opcode", "Category", "Count" })
			{
				this.outerInstance = outerInstance;
				types = new Type [] {typeof(string), typeof(string), typeof(Integer)};
				canEdit = new bool [] {false, false, false};
			}

			internal Type[] types;
			internal bool[] canEdit;

			public Type getColumnClass(int columnIndex)
			{
				return types [columnIndex];
			}

			public bool isCellEditable(int rowIndex, int columnIndex)
			{
				return canEdit [columnIndex];
			}
		}

		private class ActionListenerAnonymousInnerClass2 : java.awt.@event.ActionListener
		{
			private readonly InstructionCounter outerInstance;

			public ActionListenerAnonymousInnerClass2(InstructionCounter outerInstance)
			{
				this.outerInstance = outerInstance;
			}

			public void actionPerformed(java.awt.@event.ActionEvent evt)
			{
				outerInstance.btnSaveActionPerformed(evt);
			}
		}

	private void btnStartActionPerformed(java.awt.@event.ActionEvent evt)
	{ //GEN-FIRST:event_btnStartActionPerformed
			btnStart.Enabled = false;
			Cursor = Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR);
			//Instances of javax.swing.SwingWorker are not reusuable, so
			//we create new instances as needed.
			progressBar.Indeterminate = true;
			task = new Task(this);
			task.addPropertyChangeListener(this);
			task.execute();
	} //GEN-LAST:event_btnStartActionPerformed

	private void btnSaveActionPerformed(java.awt.@event.ActionEvent evt)
	{ //GEN-FIRST:event_btnSaveActionPerformed
			File file;
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final javax.swing.JFileChooser fc = new javax.swing.JFileChooser();
			JFileChooser fc = new JFileChooser();
			fc.DialogTitle = java.util.ResourceBundle.getBundle("pspsharp/languages/pspsharp").getString("InstructionCounter.strSaveInstructionDialog.text");
			fc.CurrentDirectory = new File(".");
			fc.SelectedFile = new File("instructionoutput.txt");
			int returnvalue = fc.showSaveDialog(this);
			if (returnvalue == JFileChooser.APPROVE_OPTION)
			{
				file = fc.SelectedFile;
			}
			else
			{
				return;
			}
			System.IO.StreamWriter bufferedWriter = null;
			try
			{
				// construct the BufferedWriter object
				bufferedWriter = new System.IO.StreamWriter(file);

				// start writing to the output stream
				for (int i = 0; i < OpcodeTable.RowCount; i++)
				{
					bufferedWriter.BaseStream.WriteByte(OpcodeTable.getValueAt(i, 0) + "\t" + OpcodeTable.getValueAt(i, 1) + "\t" + OpcodeTable.getValueAt(i, 2));
					bufferedWriter.newLine();
				}
			}
			catch (FileNotFoundException ex)
			{
				Console.WriteLine(ex.ToString());
				Console.Write(ex.StackTrace);
			}
			catch (IOException ex)
			{
				Console.WriteLine(ex.ToString());
				Console.Write(ex.StackTrace);
			}
			finally
			{
				Utilities.close(bufferedWriter);
			}
	} //GEN-LAST:event_btnSaveActionPerformed

		/// <summary>
		/// Invoked when task's progress property changes.
		/// </summary>
		public override void propertyChange(PropertyChangeEvent evt)
		{
			if (evt.PropertyName.Equals("progress"))
			{
				int progress = (int?) evt.NewValue.Value;
				progressBar.Value = progress;
			}
		}

		public virtual void findinitsections()
		{
			for (int i = 0; i < module.initsection[1]; i += 4)
			{
				int memread32 = Memory.Instance.read32(module.initsection[0] + i);
				pspsharp.Allegrex.Decoder.instruction(memread32).increaseCount();
			}
		}

		public virtual void findfinisections()
		{
			for (int i = 0; i < module.finisection[1]; i += 4)
			{
				int memread32 = Memory.Instance.read32(module.finisection[0] + i);
				pspsharp.Allegrex.Decoder.instruction(memread32).increaseCount();
			}
		}

		public virtual void findtextsections()
		{
			for (int i = 0; i < module.text_size; i += 4)
			{
				int memread32 = Memory.Instance.read32(module.text_addr + i);
				pspsharp.Allegrex.Decoder.instruction(memread32).increaseCount();
			}
		}

		public virtual void findstubtextsections()
		{
			for (int i = 0; i < module.stubtextsection[1]; i += 4)
			{
				int memread32 = Memory.Instance.read32(module.stubtextsection[0] + i);
				pspsharp.Allegrex.Decoder.instruction(memread32).increaseCount();
			}
		}

		internal class Task : SwingWorker<Void, Void>
		{
			private readonly InstructionCounter outerInstance;

			public Task(InstructionCounter outerInstance)
			{
				this.outerInstance = outerInstance;
			}

			/*
			 * Main task. Executed in background thread.
			 */

			public override Void doInBackground()
			{
				Progress = 0;

				outerInstance.resetCounting();
				Progress = 20;

				if (outerInstance.initcheck.Selected)
				{
					outerInstance.findinitsections();
				}
				Progress = 40;

				if (outerInstance.textcheck.Selected)
				{
					outerInstance.findtextsections();
				}
				Progress = 60;

				if (outerInstance.finicheck.Selected)
				{
					outerInstance.findfinisections();
				}
				Progress = 80;

				if (outerInstance.stubtextcheck.Selected)
				{
					outerInstance.findstubtextsections();
				}
				Progress = 100;

				return null;
			}

			/*
			 * Executed in event dispatching thread
			 */
			public override void done()
			{
				outerInstance.refreshCounter();
				Toolkit.DefaultToolkit.beep();
				outerInstance.btnStart.Enabled = true;
				Cursor = null; // turn off the wait cursor
				outerInstance.progressBar.Indeterminate = false;
			}
		}
		// Let's instanciate this private member so the two following methods
		// can retrieve the right opcodes.
		public static pspsharp.Allegrex.Instructions INSTRUCTIONS = new pspsharp.Allegrex.Instructions();

		public virtual void refreshCounter()
		{
			SortedDictionary<string, Instruction> instructions = new SortedDictionary<string, Instruction>();
			foreach (Instruction insn in pspsharp.Allegrex.Common.instructions())
			{
				if (insn != null)
				{
					instructions[insn.name()] = insn;
				}
			}
			foreach (Instruction insn in instructions.Values)
			{
				if (insn != null && insn.Count > 0)
				{
					((DefaultTableModel) OpcodeTable.Model).addRow(new object[]{insn.name(), insn.category(), new int?(insn.Count)});
				}
			}
		}

		public virtual void resetCounting()
		{
			foreach (Instruction insn in pspsharp.Allegrex.Common.instructions())
			{
				if (insn != null)
				{
					insn.resetCount();
				}
			}
			((DefaultTableModel) OpcodeTable.Model).RowCount = 0;
		}

		public override void dispose()
		{
			Emulator.MainGUI.endWindowDialog();
			base.dispose();
		}
		// Variables declaration - do not modify//GEN-BEGIN:variables
		private javax.swing.JTable OpcodeTable;
		private javax.swing.JTextArea areastatus;
		private javax.swing.JButton btnSave;
		private javax.swing.JButton btnStart;
		private javax.swing.JCheckBox finicheck;
		private javax.swing.JCheckBox initcheck;
		private javax.swing.JScrollPane jScrollPane1;
		private javax.swing.JScrollPane jScrollPane2;
		private javax.swing.JLabel lblCountWhat;
		private javax.swing.JProgressBar progressBar;
		private javax.swing.JCheckBox stubtextcheck;
		private javax.swing.JCheckBox textcheck;
		// End of variables declaration//GEN-END:variables
	}

}