/*
This file is part of pspsharp.

pspsharp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

pspsharp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with pspsharp.  If not, see <http://www.gnu.org/licenses/>.
 */
namespace pspsharp.HLE.modules
{
	using Logger = org.apache.log4j.Logger;

	using LengthInfo = pspsharp.HLE.BufferInfo.LengthInfo;
	using Usage = pspsharp.HLE.BufferInfo.Usage;
	using CryptoEngine = pspsharp.crypto.CryptoEngine;
	using SAVEDATA = pspsharp.crypto.SAVEDATA;
	using Utilities = pspsharp.util.Utilities;

	public class sceChnnlsv : HLEModule
	{
		public static Logger log = Modules.getLogger("sceChnnlsv");
		private CryptoEngine crypto = new CryptoEngine();

		/// <summary>
		/// Initialize the SceSdCtx2 struct and set the mode.
		/// </summary>
		/// <param name="ctx"> Pointer to the SceSdCtx2 struct </param>
		/// <param name="mode"> One of the modes whichs sets the scramble key for kirk.
		/// </param>
		/// <returns> SCE_ERROR_OK on initialization success. </returns>
		/// <returns> SCE_CHNNLSV_ERROR_ILLEGAL_ADDR if ctx cannot be accessed from the current context.
		///  </returns>
//JAVA TO C# CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
//ORIGINAL LINE: @HLEFunction(nid = 0xE7833020, version = 150) public int sceSdSetIndex(@BufferInfo(lengthInfo=pspsharp.HLE.BufferInfo.LengthInfo.fixedLength, length=40, usage=pspsharp.HLE.BufferInfo.Usage.out) pspsharp.HLE.TPointer ctx2Addr, int mode)
		[HLEFunction(nid : 0xE7833020, version : 150)]
		public virtual int sceSdSetIndex(TPointer ctx2Addr, int mode)
		{
			SAVEDATA.SD_Ctx1 ctx = new SAVEDATA.SD_Ctx1();

			int result = crypto.SAVEDATAEngine.hleSdSetIndex(ctx, mode);

			ctx.write(ctx2Addr);

			return result;
		}

		/// <summary>
		/// Generates a hash storing the result into ctx->data and updates ctx->key
		/// </summary>
		/// <param name="ctx"> Pointer to the SceSdCtx2 struct </param>
		/// <param name="data"> Pointer to the data used in hash generation </param>
		/// <param name="size"> The size of the data used for hash generation
		/// </param>
		/// <returns> SCE_ERROR_OK on success </returns>
		/// <returns> SCE_CHNNLSV_ERROR_ILLEGAL_ADDR if ctx/data cannot be accessed from the current context. </returns>
		/// <returns> SCE_CHNNLSV_ERROR_SEMA_ERROR wait/signal sema error </returns>
		/// <returns> SCE_CHNNLSV_ERROR_ILLEGAL_SIZE if ctx->size > 16
		///  </returns>
//JAVA TO C# CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
//ORIGINAL LINE: @HLEFunction(nid = 0xF21A1FCA, version = 150) public int sceSdRemoveValue(@BufferInfo(lengthInfo=pspsharp.HLE.BufferInfo.LengthInfo.fixedLength, length=40, usage=pspsharp.HLE.BufferInfo.Usage.inout) pspsharp.HLE.TPointer ctx2Addr, @BufferInfo(lengthInfo=pspsharp.HLE.BufferInfo.LengthInfo.nextParameter, usage=pspsharp.HLE.BufferInfo.Usage.in) pspsharp.HLE.TPointer data, int size)
		[HLEFunction(nid : 0xF21A1FCA, version : 150)]
		public virtual int sceSdRemoveValue(TPointer ctx2Addr, TPointer data, int size)
		{
			SAVEDATA.SD_Ctx1 ctx = new SAVEDATA.SD_Ctx1();
			ctx.read(ctx2Addr);

			sbyte[] bytes = new sbyte[size];
			Utilities.readBytes(data.Address, size, bytes, 0);
			int result = crypto.SAVEDATAEngine.hleSdRemoveValue(ctx, bytes, size);

			ctx.write(ctx2Addr);

			return result;
		}

		/// <summary>
		/// Generates a hash based on the context collected by sceSdRemoveValue,
		/// the results of which are stored into the SAVEDATA_PARAMS field of PARAM.SFO
		/// </summary>
		/// <param name="ctx"> Pointer to the SceSdCtx2 struct </param>
		/// <param name="hash"> The end result of the hash generated by this function is stored here </param>
		/// <param name="key"> If provided, this key will also be used in the encryption process
		/// </param>
		/// <returns> SCE_ERROR_OK on success </returns>
		/// <returns> SCE_CHNNLSV_ERROR_ILLEGAL_ADDR if ctx/hash/key cannot be accessed from the current context. </returns>
		/// <returns> SCE_CHNNLSV_ERROR_SEMA_ERROR wait/signal sema error </returns>
		/// <returns> SCE_CHNNLSV_ERROR_ILLEGAL_SIZE if ctx->size > 16
		///  </returns>
//JAVA TO C# CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
//ORIGINAL LINE: @HLEFunction(nid = 0xC4C494F8, version = 150) public int sceSdGetLastIndex(@BufferInfo(lengthInfo=pspsharp.HLE.BufferInfo.LengthInfo.fixedLength, length=40, usage=pspsharp.HLE.BufferInfo.Usage.inout) pspsharp.HLE.TPointer ctx2Addr, @BufferInfo(lengthInfo=pspsharp.HLE.BufferInfo.LengthInfo.fixedLength, length=16, usage=pspsharp.HLE.BufferInfo.Usage.out) pspsharp.HLE.TPointer8 hash, @CanBeNull @BufferInfo(lengthInfo=pspsharp.HLE.BufferInfo.LengthInfo.fixedLength, length=16, usage=pspsharp.HLE.BufferInfo.Usage.in) pspsharp.HLE.TPointer8 key)
		[HLEFunction(nid : 0xC4C494F8, version : 150)]
		public virtual int sceSdGetLastIndex(TPointer ctx2Addr, TPointer8 hash, TPointer8 key)
		{
			SAVEDATA.SD_Ctx1 ctx = new SAVEDATA.SD_Ctx1();
			ctx.read(ctx2Addr);

			sbyte[] hashBytes = new sbyte[16];

			sbyte[] keyBytes;
			if (key.Null)
			{
				keyBytes = null;
			}
			else
			{
				keyBytes = new sbyte[16];
				Utilities.readBytes(key.Address, keyBytes.Length, keyBytes, 0);
			}

			int result = crypto.SAVEDATAEngine.hleSdGetLastIndex(ctx, hashBytes, keyBytes);

			Utilities.writeBytes(hash.Address, hashBytes.Length, hashBytes, 0);

			ctx.write(ctx2Addr);

			return result;
		}

		/// <summary>
		/// The main key generating function, 1 for encryption, 2 for decryption
		/// </summary>
		/// <param name="ctx"> Pointer to the SceSdCtx1 struct </param>
		/// <param name="mode"> Different public keys/kirk commands will be used depending on the mode specified </param>
		/// <param name="genMode"> Specify whether encryption (1) or decryption (1) should be used </param>
		/// <param name="data"> Pointer to some data used for encryption/decryption </param>
		/// <param name="key"> If specified, this key will be used as the private key for encryption/decryption
		/// </param>
		/// <returns> SCE_ERROR_OK on success </returns>
		/// <returns> SCE_CHNNLSV_ERROR_ILLEGAL_ADDR if ctx/data/key cannot be accessed from the current context. </returns>
		/// <returns> SCE_CHNNLSV_ERROR_SEMA_ERROR wait/signal sema error
		///  </returns>
//JAVA TO C# CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
//ORIGINAL LINE: @HLEFunction(nid = 0xABFDFC8B, version = 150) public int sceSdCreateList(@BufferInfo(lengthInfo=pspsharp.HLE.BufferInfo.LengthInfo.fixedLength, length=24, usage=pspsharp.HLE.BufferInfo.Usage.inout) pspsharp.HLE.TPointer ctx2Addr, int encMode, int genMode, @BufferInfo(lengthInfo=pspsharp.HLE.BufferInfo.LengthInfo.fixedLength, length=16, usage=pspsharp.HLE.BufferInfo.Usage.inout) pspsharp.HLE.TPointer8 data, @CanBeNull @BufferInfo(lengthInfo=pspsharp.HLE.BufferInfo.LengthInfo.fixedLength, length=16, usage=pspsharp.HLE.BufferInfo.Usage.in) pspsharp.HLE.TPointer8 key)
		[HLEFunction(nid : 0xABFDFC8B, version : 150)]
		public virtual int sceSdCreateList(TPointer ctx2Addr, int encMode, int genMode, TPointer8 data, TPointer8 key)
		{
			SAVEDATA.SD_Ctx2 ctx = new SAVEDATA.SD_Ctx2();
			ctx.read(ctx2Addr);

			sbyte[] dataBytes;
			if (data.Null)
			{
				dataBytes = null;
			}
			else
			{
				dataBytes = new sbyte[16];
				Utilities.readBytes(data.Address, dataBytes.Length, dataBytes, 0);
			}

			sbyte[] keyBytes;
			if (key.Null)
			{
				keyBytes = null;
			}
			else
			{
				keyBytes = new sbyte[16];
				Utilities.readBytes(key.Address, keyBytes.Length, keyBytes, 0);
			}

			int result = crypto.SAVEDATAEngine.hleSdCreateList(ctx, encMode, genMode, dataBytes, keyBytes);

			if (dataBytes != null)
			{
				Utilities.writeBytes(data.Address, dataBytes.Length, dataBytes, 0);
			}
			if (keyBytes != null)
			{
				Utilities.writeBytes(key.Address, keyBytes.Length, keyBytes, 0);
			}

			ctx.write(ctx2Addr);

			return result;
		}

		/// <summary>
		/// The main encryption/decryption function, the size of "data" must be 16 byte aligned
		/// </summary>
		/// <param name="ctx"> Pointer to the SceSdCtx1 struct </param>
		/// <param name="data"> Pointer to the data used in the encryption/decryption process </param>
		/// <param name="size"> The size of "data"
		/// </param>
		/// <returns> SCE_ERROR_OK on success </returns>
		/// <returns> SCE_CHNNLSV_ERROR_ILLEGAL_ADDR if ctx/data cannot be accessed from the current context. </returns>
		/// <returns> SCE_CHNNLSV_ERROR_SEMA_ERROR wait/signal sema error </returns>
		/// <returns> SCE_CHNNLSV_ERROR_ILLEGAL_ALIGNMENT_SIZE if the size of "data" is not 16 byte aligned
		///  </returns>
//JAVA TO C# CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
//ORIGINAL LINE: @HLEFunction(nid = 0x850A7FA1, version = 150) public int sceSdSetMember(@BufferInfo(lengthInfo=pspsharp.HLE.BufferInfo.LengthInfo.fixedLength, length=24, usage=pspsharp.HLE.BufferInfo.Usage.inout) pspsharp.HLE.TPointer ctx2Addr, @BufferInfo(lengthInfo=pspsharp.HLE.BufferInfo.LengthInfo.nextParameter, usage=pspsharp.HLE.BufferInfo.Usage.inout) pspsharp.HLE.TPointer8 data, int dataLength)
		[HLEFunction(nid : 0x850A7FA1, version : 150)]
		public virtual int sceSdSetMember(TPointer ctx2Addr, TPointer8 data, int dataLength)
		{
			SAVEDATA.SD_Ctx2 ctx = new SAVEDATA.SD_Ctx2();
			ctx.read(ctx2Addr);

			sbyte[] dataBytes = new sbyte[dataLength];
			Utilities.readBytes(data.Address, dataLength, dataBytes, 0);

			int result = crypto.SAVEDATAEngine.hleSdSetMember(ctx, dataBytes, dataLength);

			Utilities.writeBytes(data.Address, dataBytes.Length, dataBytes, 0);

			ctx.write(ctx2Addr);

			return result;
		}

		/// <summary>
		/// Initialize the SceSdCtx1 struct.
		/// </summary>
		/// <param name="ctx"> Pointer to the SceSdCtx1 struct
		/// </param>
		/// <returns> SCE_ERROR_OK on initialization success. </returns>
		/// <returns> SCE_CHNNLSV_ERROR_ILLEGAL_ADDR if ctx cannot be accessed from the current context.
		///  </returns>
//JAVA TO C# CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
//ORIGINAL LINE: @HLEFunction(nid = 0x21BE78B4, version = 150) public int sceSdCleanList(@BufferInfo(lengthInfo=pspsharp.HLE.BufferInfo.LengthInfo.fixedLength, length=24, usage=pspsharp.HLE.BufferInfo.Usage.out) pspsharp.HLE.TPointer ctx2Addr)
		[HLEFunction(nid : 0x21BE78B4, version : 150)]
		public virtual int sceSdCleanList(TPointer ctx2Addr)
		{
			SAVEDATA.SD_Ctx2 ctx = new SAVEDATA.SD_Ctx2();
			ctx.read(ctx2Addr);

			int result = crypto.SAVEDATAEngine.hleSdCleanList(ctx);

			ctx.write(ctx2Addr);

			return result;
		}
	}

}